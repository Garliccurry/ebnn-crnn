基于ebnn的衍生项目，主要是用CRNN网络做OCR识别。文件分为三个部分：python训练，c语言版本底层算子以及在STM32H743上面的实验 。

- - -
# 1. Network 网络
## 1.1 python依赖
python的库需求如`/python/requirements.txt`所示，`cuda`和`cudnn`可以直接用 `Anaconda` 下载：
```
matplotlib==3.6.2
numpy==1.19.2
Pillow==10.4.0
torch==2.0.0+cu118
torchvision==0.15.1+cu118
tqdm==4.66.2
python ==3.8 
``` 
## 1.2 文件组成

**1.2.1 数据集**
	由STM32H743上的OV2640采集后通过框选、线性插值成250\*50大小的二值化图案，再利用串口传输给PC绘制成图片。`labels.txt`里面包含对应文件名的标签，格式如下：

|    文件名    |  标签内容  |
| :-------: | :----: |
| 00000.png | 12345  |
| 00001.png | 67890  |
| 00002.png | CARRY  |
|  ......   | ...... |

同一行的内容以`","`为间隔符号。如果训练时想要略过某些数据集，删除掉指定行的内容即可。

**1.2.2  网络**
所有的二值化、量化操作在`bnn_ops.py`，基础的网络层操作在`bnn_layer.py`，`crnn.py`是网络主体。*output_num*是字库数量，网络结构如下：

|    网络操作    |           特征图片大小            |
| :--------: | :-------------------------: |
|     原始     |     [batch, 1, 50, 250]     |
|    卷积1     |     [batch, 4, 50, 250]     |
|    池化1     |     [batch, 4, 25, 125]     |
|    卷积2     |    [batch, 32, 24, 124]     |
|    池化2     |     [batch, 32, 6, 62]      |
|    卷积3     |     [batch, 64, 6, 62]      |
|    池化3     |     [batch, 64, 2, 31]      |
|    卷积4     |     [batch, 128, 2, 30]     |
|    池化4     |     [batch, 128, 1, 15]     |
| 合并通道与高度，换维 |     [batch, 15, 128\*1]     |
|    全连接1    |       [batch, 15, 64]       |
|     换维     |       [15, batch, 64]       |
|    双向循环    |      [15, batch, 256]       |
|    全连接     | [15, batch, *output_num*+1] |

**1.2.3 原理**

这个默认版本的BNN采用的是二值化权重，激活值(临时值)采用浮点数，训练文件为`crnn-pytorch_chinese_BNN.ipynb`。激活值二值化会导致网络训练无法收敛，尝试过激活值量化为int8(256态)/int4(16态)时仍然可以训练。可以改变`bnn_ops.py`的`"Q_factor"`来修改量化位数，量化 `x` 位公式如下：
$$
{Q_{factor}} = 2^{x-1} -1
$$
再将训练网络设定为QCRNN进行训练即可。

**1.2.4 文件导出**

`crnn-pytorch_chinese_genc.ipynb`是用于将训练好后的权重导出为c文件，以8位无符号整型`uint8_t`格式存储，每1个字节的8位存储8个权重。*如果要加载到嵌入式设备时记得加上 **static** 关键词*。 
# 2. C语言算子

## 2.1 内容
`ebnn.h`文件在原项目的基础上进行了修改，原本的ebnn激活值为比特类型，这里改成了浮点数存储主要是为了保持网络精度。还编写了`int8`类型存储激活值的版本(*仅验证功能正常，没有运行网络整体验证*)。 除此之外还有二值化权重版本的LSTM函数、ctc转录以及维度变换函数。
## 2.2 测试
可以直接用codeblocks打开运行，其结果为“厦门市很好”。如果用VSCode打开乱码的话是因为有的c文件是ANSI格式，建议以记事本方式打开并复制过去运行。 但是哈，VSCode联合多文件编译这个过程比较麻烦（gcc main.c func1.c ebnn.c -o main），不建议。
# 3.STM32H7
最后就是将c文件放入STM32H743进行推理训练，再将结果打印到串口。
