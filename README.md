基于原本ebnn的衍生项目，主要是用CRNN网络做OCR识别
文件分为三个部分：python训练部分，c语言版本底层算子以及在STM32H743上面的实验
——————————————————————————————————————————————————

python的库需求如/python/requirements.txt所示：
		matplotlib==3.6.2
		numpy==1.19.2
		Pillow==10.4.0
		torch==2.0.0+cu118
		torchvision==0.15.1+cu118
		tqdm==4.66.2
		python ==3.8

所有的二值化操作在bnn_ops.py，基础的网络层操作在bnn_layer.py
crnn-pytorch_chinese_BNN.ipynb是训练的主体函数，数据集需要解压

数据集是由STM32H743上的OV2640采集后通过线性插值成250*50的大小后二值化，再利用串口传输给PC绘制成图片。
labels.txt里面包含对应文件名的标签，如果训练时想要略过某些数据集直接删除掉就行了

我这个默认版本的BNN采用的是二值化权重，激活值(临时值)采用浮点数，训练文件为crnn-pytorch_chinese_BNN.ipynb。激活值二值化会导致网络训练无法收敛，但是尝试过激活值量化为int8(256态)/int4(16态)时任可以训练。修改量化位数可以改变bnn_ops.py的"Q_factor"，再将训练网络设定为QCRNN。

crnn-pytorch_chinese_genc.ipynb是用于将训练好后的权重导出为c文件，以8位无符号整型(uint8_t)存储，每1个字节的8位存储8个权重，如果要加载到嵌入式设备时记得加上static关键词。
——————————————————————————————————————————————————

ebnn.h文件在原项目的基础上进行了修改，原本的ebnn激活值为uint8_t类型，这里改成了浮点数存储，还编写了int8类型存储激活值的版本(仅验证功能正常，没有运行网络整体验证)。
还写了二值化权重版本的LSTM函数、ctc转录以及维度变换函数。

可以直接用codeblock打开运行，其结果为“厦门市很好”。如果用vscode打开乱码的话是因为有的c文件是ANSI格式，建议以记事本方式打开并复制过去运行。
——————————————————————————————————————————————————

最后就是将c文件放入STM32H743进行推理训练，再将结果打印到串口。

